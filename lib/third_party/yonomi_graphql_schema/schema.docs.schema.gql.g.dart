// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'schema.docs.schema.gql.dart';

// **************************************************************************
// BuiltValueGenerator
// **************************************************************************

const GThermostatMode _$gThermostatModeOFF = const GThermostatMode._('OFF');
const GThermostatMode _$gThermostatModeAUTO = const GThermostatMode._('AUTO');
const GThermostatMode _$gThermostatModeHEAT = const GThermostatMode._('HEAT');
const GThermostatMode _$gThermostatModeCOOL = const GThermostatMode._('COOL');
const GThermostatMode _$gThermostatModeFANONLY =
    const GThermostatMode._('FANONLY');
const GThermostatMode _$gThermostatModeDEHUMIDIFY =
    const GThermostatMode._('DEHUMIDIFY');
const GThermostatMode _$gThermostatModeAIRFLOW =
    const GThermostatMode._('AIRFLOW');

GThermostatMode _$gThermostatModeValueOf(String name) {
  switch (name) {
    case 'OFF':
      return _$gThermostatModeOFF;
    case 'AUTO':
      return _$gThermostatModeAUTO;
    case 'HEAT':
      return _$gThermostatModeHEAT;
    case 'COOL':
      return _$gThermostatModeCOOL;
    case 'FANONLY':
      return _$gThermostatModeFANONLY;
    case 'DEHUMIDIFY':
      return _$gThermostatModeDEHUMIDIFY;
    case 'AIRFLOW':
      return _$gThermostatModeAIRFLOW;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GThermostatMode> _$gThermostatModeValues =
    new BuiltSet<GThermostatMode>(const <GThermostatMode>[
  _$gThermostatModeOFF,
  _$gThermostatModeAUTO,
  _$gThermostatModeHEAT,
  _$gThermostatModeCOOL,
  _$gThermostatModeFANONLY,
  _$gThermostatModeDEHUMIDIFY,
  _$gThermostatModeAIRFLOW,
]);

const GFanMode _$gFanModeON = const GFanMode._('ON');
const GFanMode _$gFanModeAUTO = const GFanMode._('AUTO');
const GFanMode _$gFanModeCIRCULATE = const GFanMode._('CIRCULATE');
const GFanMode _$gFanModeSWAY = const GFanMode._('SWAY');
const GFanMode _$gFanModeWIND = const GFanMode._('WIND');
const GFanMode _$gFanModeHEALTH = const GFanMode._('HEALTH');
const GFanMode _$gFanModeHUMIDITY = const GFanMode._('HUMIDITY');
const GFanMode _$gFanModeECO = const GFanMode._('ECO');
const GFanMode _$gFanModeENERGY = const GFanMode._('ENERGY');
const GFanMode _$gFanModeFRESH = const GFanMode._('FRESH');
const GFanMode _$gFanModeTASTE = const GFanMode._('TASTE');
const GFanMode _$gFanModeLOW = const GFanMode._('LOW');
const GFanMode _$gFanModeMEDIUM = const GFanMode._('MEDIUM');
const GFanMode _$gFanModeHIGH = const GFanMode._('HIGH');

GFanMode _$gFanModeValueOf(String name) {
  switch (name) {
    case 'ON':
      return _$gFanModeON;
    case 'AUTO':
      return _$gFanModeAUTO;
    case 'CIRCULATE':
      return _$gFanModeCIRCULATE;
    case 'SWAY':
      return _$gFanModeSWAY;
    case 'WIND':
      return _$gFanModeWIND;
    case 'HEALTH':
      return _$gFanModeHEALTH;
    case 'HUMIDITY':
      return _$gFanModeHUMIDITY;
    case 'ECO':
      return _$gFanModeECO;
    case 'ENERGY':
      return _$gFanModeENERGY;
    case 'FRESH':
      return _$gFanModeFRESH;
    case 'TASTE':
      return _$gFanModeTASTE;
    case 'LOW':
      return _$gFanModeLOW;
    case 'MEDIUM':
      return _$gFanModeMEDIUM;
    case 'HIGH':
      return _$gFanModeHIGH;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GFanMode> _$gFanModeValues =
    new BuiltSet<GFanMode>(const <GFanMode>[
  _$gFanModeON,
  _$gFanModeAUTO,
  _$gFanModeCIRCULATE,
  _$gFanModeSWAY,
  _$gFanModeWIND,
  _$gFanModeHEALTH,
  _$gFanModeHUMIDITY,
  _$gFanModeECO,
  _$gFanModeENERGY,
  _$gFanModeFRESH,
  _$gFanModeTASTE,
  _$gFanModeLOW,
  _$gFanModeMEDIUM,
  _$gFanModeHIGH,
]);

const GTraitName _$gTraitNameBATTERY_LEVEL =
    const GTraitName._('BATTERY_LEVEL');
const GTraitName _$gTraitNameBRIGHTNESS = const GTraitName._('BRIGHTNESS');
const GTraitName _$gTraitNameCOLOR = const GTraitName._('COLOR');
const GTraitName _$gTraitNameCOLOR_TEMPERATURE =
    const GTraitName._('COLOR_TEMPERATURE');
const GTraitName _$gTraitNameLOCK = const GTraitName._('LOCK');
const GTraitName _$gTraitNamePIN_CODE_CREDENTIAL =
    const GTraitName._('PIN_CODE_CREDENTIAL');
const GTraitName _$gTraitNamePOWER = const GTraitName._('POWER');
const GTraitName _$gTraitNameTHERMOSTAT_SETTING =
    const GTraitName._('THERMOSTAT_SETTING');

GTraitName _$gTraitNameValueOf(String name) {
  switch (name) {
    case 'BATTERY_LEVEL':
      return _$gTraitNameBATTERY_LEVEL;
    case 'BRIGHTNESS':
      return _$gTraitNameBRIGHTNESS;
    case 'COLOR':
      return _$gTraitNameCOLOR;
    case 'COLOR_TEMPERATURE':
      return _$gTraitNameCOLOR_TEMPERATURE;
    case 'LOCK':
      return _$gTraitNameLOCK;
    case 'PIN_CODE_CREDENTIAL':
      return _$gTraitNamePIN_CODE_CREDENTIAL;
    case 'POWER':
      return _$gTraitNamePOWER;
    case 'THERMOSTAT_SETTING':
      return _$gTraitNameTHERMOSTAT_SETTING;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GTraitName> _$gTraitNameValues =
    new BuiltSet<GTraitName>(const <GTraitName>[
  _$gTraitNameBATTERY_LEVEL,
  _$gTraitNameBRIGHTNESS,
  _$gTraitNameCOLOR,
  _$gTraitNameCOLOR_TEMPERATURE,
  _$gTraitNameLOCK,
  _$gTraitNamePIN_CODE_CREDENTIAL,
  _$gTraitNamePOWER,
  _$gTraitNameTHERMOSTAT_SETTING,
]);

const GVIRTUAL_CONNECTOR_ActionStatus _$gVIRTUALCONNECTORActionStatusRESOLVED =
    const GVIRTUAL_CONNECTOR_ActionStatus._('RESOLVED');
const GVIRTUAL_CONNECTOR_ActionStatus _$gVIRTUALCONNECTORActionStatusREJECTED =
    const GVIRTUAL_CONNECTOR_ActionStatus._('REJECTED');

GVIRTUAL_CONNECTOR_ActionStatus _$gVIRTUALCONNECTORActionStatusValueOf(
    String name) {
  switch (name) {
    case 'RESOLVED':
      return _$gVIRTUALCONNECTORActionStatusRESOLVED;
    case 'REJECTED':
      return _$gVIRTUALCONNECTORActionStatusREJECTED;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GVIRTUAL_CONNECTOR_ActionStatus>
    _$gVIRTUALCONNECTORActionStatusValues =
    new BuiltSet<GVIRTUAL_CONNECTOR_ActionStatus>(const <
        GVIRTUAL_CONNECTOR_ActionStatus>[
  _$gVIRTUALCONNECTORActionStatusRESOLVED,
  _$gVIRTUALCONNECTORActionStatusREJECTED,
]);

const GIntegrationType _$gIntegrationTypefirstParty =
    const GIntegrationType._('firstParty');
const GIntegrationType _$gIntegrationTypethirdParty =
    const GIntegrationType._('thirdParty');

GIntegrationType _$gIntegrationTypeValueOf(String name) {
  switch (name) {
    case 'firstParty':
      return _$gIntegrationTypefirstParty;
    case 'thirdParty':
      return _$gIntegrationTypethirdParty;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GIntegrationType> _$gIntegrationTypeValues =
    new BuiltSet<GIntegrationType>(const <GIntegrationType>[
  _$gIntegrationTypefirstParty,
  _$gIntegrationTypethirdParty,
]);

const GLinkedAccountAuthorizedStatus
    _$gLinkedAccountAuthorizedStatusAUTHORIZED =
    const GLinkedAccountAuthorizedStatus._('AUTHORIZED');
const GLinkedAccountAuthorizedStatus
    _$gLinkedAccountAuthorizedStatusNOT_AUTHORIZED =
    const GLinkedAccountAuthorizedStatus._('NOT_AUTHORIZED');

GLinkedAccountAuthorizedStatus _$gLinkedAccountAuthorizedStatusValueOf(
    String name) {
  switch (name) {
    case 'AUTHORIZED':
      return _$gLinkedAccountAuthorizedStatusAUTHORIZED;
    case 'NOT_AUTHORIZED':
      return _$gLinkedAccountAuthorizedStatusNOT_AUTHORIZED;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GLinkedAccountAuthorizedStatus>
    _$gLinkedAccountAuthorizedStatusValues = new BuiltSet<
        GLinkedAccountAuthorizedStatus>(const <GLinkedAccountAuthorizedStatus>[
  _$gLinkedAccountAuthorizedStatusAUTHORIZED,
  _$gLinkedAccountAuthorizedStatusNOT_AUTHORIZED,
]);

const GDeviceActionStatus _$gDeviceActionStatusPENDING =
    const GDeviceActionStatus._('PENDING');
const GDeviceActionStatus _$gDeviceActionStatusRESOLVED =
    const GDeviceActionStatus._('RESOLVED');
const GDeviceActionStatus _$gDeviceActionStatusREJECTED =
    const GDeviceActionStatus._('REJECTED');
const GDeviceActionStatus _$gDeviceActionStatusERROR =
    const GDeviceActionStatus._('ERROR');
const GDeviceActionStatus _$gDeviceActionStatusFAILED =
    const GDeviceActionStatus._('FAILED');
const GDeviceActionStatus _$gDeviceActionStatusTIMEOUT =
    const GDeviceActionStatus._('TIMEOUT');
const GDeviceActionStatus _$gDeviceActionStatusCANCELED =
    const GDeviceActionStatus._('CANCELED');

GDeviceActionStatus _$gDeviceActionStatusValueOf(String name) {
  switch (name) {
    case 'PENDING':
      return _$gDeviceActionStatusPENDING;
    case 'RESOLVED':
      return _$gDeviceActionStatusRESOLVED;
    case 'REJECTED':
      return _$gDeviceActionStatusREJECTED;
    case 'ERROR':
      return _$gDeviceActionStatusERROR;
    case 'FAILED':
      return _$gDeviceActionStatusFAILED;
    case 'TIMEOUT':
      return _$gDeviceActionStatusTIMEOUT;
    case 'CANCELED':
      return _$gDeviceActionStatusCANCELED;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GDeviceActionStatus> _$gDeviceActionStatusValues =
    new BuiltSet<GDeviceActionStatus>(const <GDeviceActionStatus>[
  _$gDeviceActionStatusPENDING,
  _$gDeviceActionStatusRESOLVED,
  _$gDeviceActionStatusREJECTED,
  _$gDeviceActionStatusERROR,
  _$gDeviceActionStatusFAILED,
  _$gDeviceActionStatusTIMEOUT,
  _$gDeviceActionStatusCANCELED,
]);

const GDeviceEventTypeName _$gDeviceEventTypeNameDEVICE_ACTION_CREATED =
    const GDeviceEventTypeName._('DEVICE_ACTION_CREATED');
const GDeviceEventTypeName _$gDeviceEventTypeNameDEVICE_ACTION_UPDATED =
    const GDeviceEventTypeName._('DEVICE_ACTION_UPDATED');
const GDeviceEventTypeName _$gDeviceEventTypeNameDEVICE_STATE_UPDATED =
    const GDeviceEventTypeName._('DEVICE_STATE_UPDATED');
const GDeviceEventTypeName _$gDeviceEventTypeNameDEVICE_STATE_CLEARED =
    const GDeviceEventTypeName._('DEVICE_STATE_CLEARED');
const GDeviceEventTypeName _$gDeviceEventTypeNameDEVICE_CONFIGURED =
    const GDeviceEventTypeName._('DEVICE_CONFIGURED');

GDeviceEventTypeName _$gDeviceEventTypeNameValueOf(String name) {
  switch (name) {
    case 'DEVICE_ACTION_CREATED':
      return _$gDeviceEventTypeNameDEVICE_ACTION_CREATED;
    case 'DEVICE_ACTION_UPDATED':
      return _$gDeviceEventTypeNameDEVICE_ACTION_UPDATED;
    case 'DEVICE_STATE_UPDATED':
      return _$gDeviceEventTypeNameDEVICE_STATE_UPDATED;
    case 'DEVICE_STATE_CLEARED':
      return _$gDeviceEventTypeNameDEVICE_STATE_CLEARED;
    case 'DEVICE_CONFIGURED':
      return _$gDeviceEventTypeNameDEVICE_CONFIGURED;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GDeviceEventTypeName> _$gDeviceEventTypeNameValues =
    new BuiltSet<GDeviceEventTypeName>(const <GDeviceEventTypeName>[
  _$gDeviceEventTypeNameDEVICE_ACTION_CREATED,
  _$gDeviceEventTypeNameDEVICE_ACTION_UPDATED,
  _$gDeviceEventTypeNameDEVICE_STATE_UPDATED,
  _$gDeviceEventTypeNameDEVICE_STATE_CLEARED,
  _$gDeviceEventTypeNameDEVICE_CONFIGURED,
]);

const GDeviceEventSortInput _$gDeviceEventSortInputASCENDING =
    const GDeviceEventSortInput._('ASCENDING');
const GDeviceEventSortInput _$gDeviceEventSortInputDESCENDING =
    const GDeviceEventSortInput._('DESCENDING');

GDeviceEventSortInput _$gDeviceEventSortInputValueOf(String name) {
  switch (name) {
    case 'ASCENDING':
      return _$gDeviceEventSortInputASCENDING;
    case 'DESCENDING':
      return _$gDeviceEventSortInputDESCENDING;
    default:
      throw new ArgumentError(name);
  }
}

final BuiltSet<GDeviceEventSortInput> _$gDeviceEventSortInputValues =
    new BuiltSet<GDeviceEventSortInput>(const <GDeviceEventSortInput>[
  _$gDeviceEventSortInputASCENDING,
  _$gDeviceEventSortInputDESCENDING,
]);

Serializer<GMockConnectorRequestsFilters>
    _$gMockConnectorRequestsFiltersSerializer =
    new _$GMockConnectorRequestsFiltersSerializer();
Serializer<GHSBColorValueInput> _$gHSBColorValueInputSerializer =
    new _$GHSBColorValueInputSerializer();
Serializer<GPinCodeCredentialInput> _$gPinCodeCredentialInputSerializer =
    new _$GPinCodeCredentialInputSerializer();
Serializer<GPinCodeCredentialItemInput>
    _$gPinCodeCredentialItemInputSerializer =
    new _$GPinCodeCredentialItemInputSerializer();
Serializer<GRecurringScheduleInput> _$gRecurringScheduleInputSerializer =
    new _$GRecurringScheduleInputSerializer();
Serializer<GTemporaryScheduleInput> _$gTemporaryScheduleInputSerializer =
    new _$GTemporaryScheduleInputSerializer();
Serializer<GThermostatMode> _$gThermostatModeSerializer =
    new _$GThermostatModeSerializer();
Serializer<GFanMode> _$gFanModeSerializer = new _$GFanModeSerializer();
Serializer<GThermostatRangeInput> _$gThermostatRangeInputSerializer =
    new _$GThermostatRangeInputSerializer();
Serializer<GTraitName> _$gTraitNameSerializer = new _$GTraitNameSerializer();
Serializer<GMockReportedListStateValue>
    _$gMockReportedListStateValueSerializer =
    new _$GMockReportedListStateValueSerializer();
Serializer<GVIRTUAL_CONNECTOR_ActionStatus>
    _$gVIRTUALCONNECTORActionStatusSerializer =
    new _$GVIRTUAL_CONNECTOR_ActionStatusSerializer();
Serializer<GIntegrationType> _$gIntegrationTypeSerializer =
    new _$GIntegrationTypeSerializer();
Serializer<GDeviceFilterInput> _$gDeviceFilterInputSerializer =
    new _$GDeviceFilterInputSerializer();
Serializer<GLinkedAccountAuthorizedStatus>
    _$gLinkedAccountAuthorizedStatusSerializer =
    new _$GLinkedAccountAuthorizedStatusSerializer();
Serializer<GDeviceActionStatus> _$gDeviceActionStatusSerializer =
    new _$GDeviceActionStatusSerializer();
Serializer<GDeviceEventFilterInput> _$gDeviceEventFilterInputSerializer =
    new _$GDeviceEventFilterInputSerializer();
Serializer<GDeviceEventTypeName> _$gDeviceEventTypeNameSerializer =
    new _$GDeviceEventTypeNameSerializer();
Serializer<GDeviceEventSortInput> _$gDeviceEventSortInputSerializer =
    new _$GDeviceEventSortInputSerializer();
Serializer<GTraitFilteredEventFilterInput>
    _$gTraitFilteredEventFilterInputSerializer =
    new _$GTraitFilteredEventFilterInputSerializer();

class _$GMockConnectorRequestsFiltersSerializer
    implements StructuredSerializer<GMockConnectorRequestsFilters> {
  @override
  final Iterable<Type> types = const [
    GMockConnectorRequestsFilters,
    _$GMockConnectorRequestsFilters
  ];
  @override
  final String wireName = 'GMockConnectorRequestsFilters';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GMockConnectorRequestsFilters object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.before;
    if (value != null) {
      result
        ..add('before')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.after;
    if (value != null) {
      result
        ..add('after')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    return result;
  }

  @override
  GMockConnectorRequestsFilters deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GMockConnectorRequestsFiltersBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'before':
          result.before = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'after':
          result.after = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
      }
    }

    return result.build();
  }
}

class _$GHSBColorValueInputSerializer
    implements StructuredSerializer<GHSBColorValueInput> {
  @override
  final Iterable<Type> types = const [
    GHSBColorValueInput,
    _$GHSBColorValueInput
  ];
  @override
  final String wireName = 'GHSBColorValueInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GHSBColorValueInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'h',
      serializers.serialize(object.h, specifiedType: const FullType(int)),
      's',
      serializers.serialize(object.s, specifiedType: const FullType(int)),
      'b',
      serializers.serialize(object.b, specifiedType: const FullType(int)),
    ];

    return result;
  }

  @override
  GHSBColorValueInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GHSBColorValueInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'h':
          result.h = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          break;
        case 's':
          result.s = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          break;
        case 'b':
          result.b = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          break;
      }
    }

    return result.build();
  }
}

class _$GPinCodeCredentialInputSerializer
    implements StructuredSerializer<GPinCodeCredentialInput> {
  @override
  final Iterable<Type> types = const [
    GPinCodeCredentialInput,
    _$GPinCodeCredentialInput
  ];
  @override
  final String wireName = 'GPinCodeCredentialInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GPinCodeCredentialInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'pinCode',
      serializers.serialize(object.pinCode,
          specifiedType: const FullType(String)),
      'name',
      serializers.serialize(object.name, specifiedType: const FullType(String)),
      'schedules',
      serializers.serialize(object.schedules,
          specifiedType: const FullType(
              BuiltList, const [const FullType(GRRuleSchedule)])),
    ];

    return result;
  }

  @override
  GPinCodeCredentialInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GPinCodeCredentialInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'pinCode':
          result.pinCode = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'name':
          result.name = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'schedules':
          result.schedules.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GRRuleSchedule)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$GPinCodeCredentialItemInputSerializer
    implements StructuredSerializer<GPinCodeCredentialItemInput> {
  @override
  final Iterable<Type> types = const [
    GPinCodeCredentialItemInput,
    _$GPinCodeCredentialItemInput
  ];
  @override
  final String wireName = 'GPinCodeCredentialItemInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GPinCodeCredentialItemInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'pinCode',
      serializers.serialize(object.pinCode,
          specifiedType: const FullType(String)),
      'name',
      serializers.serialize(object.name, specifiedType: const FullType(String)),
      'alwaysActive',
      serializers.serialize(object.alwaysActive,
          specifiedType: const FullType(bool)),
      'recurringSchedules',
      serializers.serialize(object.recurringSchedules,
          specifiedType: const FullType(
              BuiltList, const [const FullType(GRecurringScheduleInput)])),
      'temporarySchedules',
      serializers.serialize(object.temporarySchedules,
          specifiedType: const FullType(
              BuiltList, const [const FullType(GTemporaryScheduleInput)])),
    ];

    return result;
  }

  @override
  GPinCodeCredentialItemInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GPinCodeCredentialItemInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'pinCode':
          result.pinCode = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'name':
          result.name = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          break;
        case 'alwaysActive':
          result.alwaysActive = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          break;
        case 'recurringSchedules':
          result.recurringSchedules.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(GRecurringScheduleInput)
              ]))! as BuiltList<Object?>);
          break;
        case 'temporarySchedules':
          result.temporarySchedules.replace(serializers.deserialize(value,
              specifiedType: const FullType(BuiltList, const [
                const FullType(GTemporaryScheduleInput)
              ]))! as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$GRecurringScheduleInputSerializer
    implements StructuredSerializer<GRecurringScheduleInput> {
  @override
  final Iterable<Type> types = const [
    GRecurringScheduleInput,
    _$GRecurringScheduleInput
  ];
  @override
  final String wireName = 'GRecurringScheduleInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GRecurringScheduleInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'duration',
      serializers.serialize(object.duration,
          specifiedType: const FullType(int)),
      'rrule',
      serializers.serialize(object.rrule,
          specifiedType: const FullType(GRRuleSchedule)),
    ];

    return result;
  }

  @override
  GRecurringScheduleInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GRecurringScheduleInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'duration':
          result.duration = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          break;
        case 'rrule':
          result.rrule.replace(serializers.deserialize(value,
                  specifiedType: const FullType(GRRuleSchedule))!
              as GRRuleSchedule);
          break;
      }
    }

    return result.build();
  }
}

class _$GTemporaryScheduleInputSerializer
    implements StructuredSerializer<GTemporaryScheduleInput> {
  @override
  final Iterable<Type> types = const [
    GTemporaryScheduleInput,
    _$GTemporaryScheduleInput
  ];
  @override
  final String wireName = 'GTemporaryScheduleInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GTemporaryScheduleInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'startDatetime',
      serializers.serialize(object.startDatetime,
          specifiedType: const FullType(GDateTime)),
      'endDatetime',
      serializers.serialize(object.endDatetime,
          specifiedType: const FullType(GDateTime)),
    ];

    return result;
  }

  @override
  GTemporaryScheduleInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GTemporaryScheduleInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'startDatetime':
          result.startDatetime.replace(serializers.deserialize(value,
              specifiedType: const FullType(GDateTime))! as GDateTime);
          break;
        case 'endDatetime':
          result.endDatetime.replace(serializers.deserialize(value,
              specifiedType: const FullType(GDateTime))! as GDateTime);
          break;
      }
    }

    return result.build();
  }
}

class _$GThermostatModeSerializer
    implements PrimitiveSerializer<GThermostatMode> {
  @override
  final Iterable<Type> types = const <Type>[GThermostatMode];
  @override
  final String wireName = 'GThermostatMode';

  @override
  Object serialize(Serializers serializers, GThermostatMode object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GThermostatMode deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GThermostatMode.valueOf(serialized as String);
}

class _$GFanModeSerializer implements PrimitiveSerializer<GFanMode> {
  @override
  final Iterable<Type> types = const <Type>[GFanMode];
  @override
  final String wireName = 'GFanMode';

  @override
  Object serialize(Serializers serializers, GFanMode object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GFanMode deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GFanMode.valueOf(serialized as String);
}

class _$GThermostatRangeInputSerializer
    implements StructuredSerializer<GThermostatRangeInput> {
  @override
  final Iterable<Type> types = const [
    GThermostatRangeInput,
    _$GThermostatRangeInput
  ];
  @override
  final String wireName = 'GThermostatRangeInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GThermostatRangeInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'setPointLow',
      serializers.serialize(object.setPointLow,
          specifiedType: const FullType(double)),
      'setPointHigh',
      serializers.serialize(object.setPointHigh,
          specifiedType: const FullType(double)),
    ];

    return result;
  }

  @override
  GThermostatRangeInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GThermostatRangeInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'setPointLow':
          result.setPointLow = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
        case 'setPointHigh':
          result.setPointHigh = serializers.deserialize(value,
              specifiedType: const FullType(double)) as double;
          break;
      }
    }

    return result.build();
  }
}

class _$GTraitNameSerializer implements PrimitiveSerializer<GTraitName> {
  @override
  final Iterable<Type> types = const <Type>[GTraitName];
  @override
  final String wireName = 'GTraitName';

  @override
  Object serialize(Serializers serializers, GTraitName object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GTraitName deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GTraitName.valueOf(serialized as String);
}

class _$GMockReportedListStateValueSerializer
    implements StructuredSerializer<GMockReportedListStateValue> {
  @override
  final Iterable<Type> types = const [
    GMockReportedListStateValue,
    _$GMockReportedListStateValue
  ];
  @override
  final String wireName = 'GMockReportedListStateValue';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GMockReportedListStateValue object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.upsert;
    if (value != null) {
      result
        ..add('upsert')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(
                BuiltList, const [const FullType(GJSONObject)])));
    }
    value = object.delete;
    if (value != null) {
      result
        ..add('delete')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(String)])));
    }
    return result;
  }

  @override
  GMockReportedListStateValue deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GMockReportedListStateValueBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'upsert':
          result.upsert.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GJSONObject)]))!
              as BuiltList<Object?>);
          break;
        case 'delete':
          result.delete.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(String)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$GVIRTUAL_CONNECTOR_ActionStatusSerializer
    implements PrimitiveSerializer<GVIRTUAL_CONNECTOR_ActionStatus> {
  @override
  final Iterable<Type> types = const <Type>[GVIRTUAL_CONNECTOR_ActionStatus];
  @override
  final String wireName = 'GVIRTUAL_CONNECTOR_ActionStatus';

  @override
  Object serialize(
          Serializers serializers, GVIRTUAL_CONNECTOR_ActionStatus object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GVIRTUAL_CONNECTOR_ActionStatus deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GVIRTUAL_CONNECTOR_ActionStatus.valueOf(serialized as String);
}

class _$GIntegrationTypeSerializer
    implements PrimitiveSerializer<GIntegrationType> {
  @override
  final Iterable<Type> types = const <Type>[GIntegrationType];
  @override
  final String wireName = 'GIntegrationType';

  @override
  Object serialize(Serializers serializers, GIntegrationType object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GIntegrationType deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GIntegrationType.valueOf(serialized as String);
}

class _$GDeviceFilterInputSerializer
    implements StructuredSerializer<GDeviceFilterInput> {
  @override
  final Iterable<Type> types = const [GDeviceFilterInput, _$GDeviceFilterInput];
  @override
  final String wireName = 'GDeviceFilterInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GDeviceFilterInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[
      'traits',
      serializers.serialize(object.traits,
          specifiedType:
              const FullType(BuiltList, const [const FullType(GTraitName)])),
    ];

    return result;
  }

  @override
  GDeviceFilterInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GDeviceFilterInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'traits':
          result.traits.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GTraitName)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$GLinkedAccountAuthorizedStatusSerializer
    implements PrimitiveSerializer<GLinkedAccountAuthorizedStatus> {
  @override
  final Iterable<Type> types = const <Type>[GLinkedAccountAuthorizedStatus];
  @override
  final String wireName = 'GLinkedAccountAuthorizedStatus';

  @override
  Object serialize(
          Serializers serializers, GLinkedAccountAuthorizedStatus object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GLinkedAccountAuthorizedStatus deserialize(
          Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GLinkedAccountAuthorizedStatus.valueOf(serialized as String);
}

class _$GDeviceActionStatusSerializer
    implements PrimitiveSerializer<GDeviceActionStatus> {
  @override
  final Iterable<Type> types = const <Type>[GDeviceActionStatus];
  @override
  final String wireName = 'GDeviceActionStatus';

  @override
  Object serialize(Serializers serializers, GDeviceActionStatus object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GDeviceActionStatus deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GDeviceActionStatus.valueOf(serialized as String);
}

class _$GDeviceEventFilterInputSerializer
    implements StructuredSerializer<GDeviceEventFilterInput> {
  @override
  final Iterable<Type> types = const [
    GDeviceEventFilterInput,
    _$GDeviceEventFilterInput
  ];
  @override
  final String wireName = 'GDeviceEventFilterInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GDeviceEventFilterInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.eventType;
    if (value != null) {
      result
        ..add('eventType')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDeviceEventTypeName)));
    }
    value = object.before;
    if (value != null) {
      result
        ..add('before')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTime)));
    }
    value = object.after;
    if (value != null) {
      result
        ..add('after')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTime)));
    }
    value = object.traitInstance;
    if (value != null) {
      result
        ..add('traitInstance')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(String)));
    }
    value = object.traits;
    if (value != null) {
      result
        ..add('traits')
        ..add(serializers.serialize(value,
            specifiedType:
                const FullType(BuiltList, const [const FullType(GTraitName)])));
    }
    return result;
  }

  @override
  GDeviceEventFilterInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GDeviceEventFilterInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'eventType':
          result.eventType = serializers.deserialize(value,
                  specifiedType: const FullType(GDeviceEventTypeName))
              as GDeviceEventTypeName?;
          break;
        case 'before':
          result.before.replace(serializers.deserialize(value,
              specifiedType: const FullType(GDateTime))! as GDateTime);
          break;
        case 'after':
          result.after.replace(serializers.deserialize(value,
              specifiedType: const FullType(GDateTime))! as GDateTime);
          break;
        case 'traitInstance':
          result.traitInstance = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String?;
          break;
        case 'traits':
          result.traits.replace(serializers.deserialize(value,
                  specifiedType: const FullType(
                      BuiltList, const [const FullType(GTraitName)]))!
              as BuiltList<Object?>);
          break;
      }
    }

    return result.build();
  }
}

class _$GDeviceEventTypeNameSerializer
    implements PrimitiveSerializer<GDeviceEventTypeName> {
  @override
  final Iterable<Type> types = const <Type>[GDeviceEventTypeName];
  @override
  final String wireName = 'GDeviceEventTypeName';

  @override
  Object serialize(Serializers serializers, GDeviceEventTypeName object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GDeviceEventTypeName deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GDeviceEventTypeName.valueOf(serialized as String);
}

class _$GDeviceEventSortInputSerializer
    implements PrimitiveSerializer<GDeviceEventSortInput> {
  @override
  final Iterable<Type> types = const <Type>[GDeviceEventSortInput];
  @override
  final String wireName = 'GDeviceEventSortInput';

  @override
  Object serialize(Serializers serializers, GDeviceEventSortInput object,
          {FullType specifiedType = FullType.unspecified}) =>
      object.name;

  @override
  GDeviceEventSortInput deserialize(Serializers serializers, Object serialized,
          {FullType specifiedType = FullType.unspecified}) =>
      GDeviceEventSortInput.valueOf(serialized as String);
}

class _$GTraitFilteredEventFilterInputSerializer
    implements StructuredSerializer<GTraitFilteredEventFilterInput> {
  @override
  final Iterable<Type> types = const [
    GTraitFilteredEventFilterInput,
    _$GTraitFilteredEventFilterInput
  ];
  @override
  final String wireName = 'GTraitFilteredEventFilterInput';

  @override
  Iterable<Object?> serialize(
      Serializers serializers, GTraitFilteredEventFilterInput object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    Object? value;
    value = object.eventType;
    if (value != null) {
      result
        ..add('eventType')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDeviceEventTypeName)));
    }
    value = object.before;
    if (value != null) {
      result
        ..add('before')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTime)));
    }
    value = object.after;
    if (value != null) {
      result
        ..add('after')
        ..add(serializers.serialize(value,
            specifiedType: const FullType(GDateTime)));
    }
    return result;
  }

  @override
  GTraitFilteredEventFilterInput deserialize(
      Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = new GTraitFilteredEventFilterInputBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;
      switch (key) {
        case 'eventType':
          result.eventType = serializers.deserialize(value,
                  specifiedType: const FullType(GDeviceEventTypeName))
              as GDeviceEventTypeName?;
          break;
        case 'before':
          result.before.replace(serializers.deserialize(value,
              specifiedType: const FullType(GDateTime))! as GDateTime);
          break;
        case 'after':
          result.after.replace(serializers.deserialize(value,
              specifiedType: const FullType(GDateTime))! as GDateTime);
          break;
      }
    }

    return result.build();
  }
}

class _$GJSON extends GJSON {
  @override
  final String value;

  factory _$GJSON([void Function(GJSONBuilder)? updates]) =>
      (new GJSONBuilder()..update(updates)).build();

  _$GJSON._({required this.value}) : super._() {
    BuiltValueNullFieldError.checkNotNull(value, 'GJSON', 'value');
  }

  @override
  GJSON rebuild(void Function(GJSONBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GJSONBuilder toBuilder() => new GJSONBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GJSON && value == other.value;
  }

  @override
  int get hashCode {
    return $jf($jc(0, value.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GJSON')..add('value', value))
        .toString();
  }
}

class GJSONBuilder implements Builder<GJSON, GJSONBuilder> {
  _$GJSON? _$v;

  String? _value;
  String? get value => _$this._value;
  set value(String? value) => _$this._value = value;

  GJSONBuilder();

  GJSONBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _value = $v.value;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GJSON other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GJSON;
  }

  @override
  void update(void Function(GJSONBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GJSON build() {
    final _$result = _$v ??
        new _$GJSON._(
            value:
                BuiltValueNullFieldError.checkNotNull(value, 'GJSON', 'value'));
    replace(_$result);
    return _$result;
  }
}

class _$GMockConnectorRequestsFilters extends GMockConnectorRequestsFilters {
  @override
  final String? before;
  @override
  final String? after;

  factory _$GMockConnectorRequestsFilters(
          [void Function(GMockConnectorRequestsFiltersBuilder)? updates]) =>
      (new GMockConnectorRequestsFiltersBuilder()..update(updates)).build();

  _$GMockConnectorRequestsFilters._({this.before, this.after}) : super._();

  @override
  GMockConnectorRequestsFilters rebuild(
          void Function(GMockConnectorRequestsFiltersBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GMockConnectorRequestsFiltersBuilder toBuilder() =>
      new GMockConnectorRequestsFiltersBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GMockConnectorRequestsFilters &&
        before == other.before &&
        after == other.after;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, before.hashCode), after.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GMockConnectorRequestsFilters')
          ..add('before', before)
          ..add('after', after))
        .toString();
  }
}

class GMockConnectorRequestsFiltersBuilder
    implements
        Builder<GMockConnectorRequestsFilters,
            GMockConnectorRequestsFiltersBuilder> {
  _$GMockConnectorRequestsFilters? _$v;

  String? _before;
  String? get before => _$this._before;
  set before(String? before) => _$this._before = before;

  String? _after;
  String? get after => _$this._after;
  set after(String? after) => _$this._after = after;

  GMockConnectorRequestsFiltersBuilder();

  GMockConnectorRequestsFiltersBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _before = $v.before;
      _after = $v.after;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GMockConnectorRequestsFilters other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GMockConnectorRequestsFilters;
  }

  @override
  void update(void Function(GMockConnectorRequestsFiltersBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GMockConnectorRequestsFilters build() {
    final _$result = _$v ??
        new _$GMockConnectorRequestsFilters._(before: before, after: after);
    replace(_$result);
    return _$result;
  }
}

class _$GHSBColorValueInput extends GHSBColorValueInput {
  @override
  final int h;
  @override
  final int s;
  @override
  final int b;

  factory _$GHSBColorValueInput(
          [void Function(GHSBColorValueInputBuilder)? updates]) =>
      (new GHSBColorValueInputBuilder()..update(updates)).build();

  _$GHSBColorValueInput._({required this.h, required this.s, required this.b})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(h, 'GHSBColorValueInput', 'h');
    BuiltValueNullFieldError.checkNotNull(s, 'GHSBColorValueInput', 's');
    BuiltValueNullFieldError.checkNotNull(b, 'GHSBColorValueInput', 'b');
  }

  @override
  GHSBColorValueInput rebuild(
          void Function(GHSBColorValueInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GHSBColorValueInputBuilder toBuilder() =>
      new GHSBColorValueInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GHSBColorValueInput &&
        h == other.h &&
        s == other.s &&
        b == other.b;
  }

  @override
  int get hashCode {
    return $jf($jc($jc($jc(0, h.hashCode), s.hashCode), b.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GHSBColorValueInput')
          ..add('h', h)
          ..add('s', s)
          ..add('b', b))
        .toString();
  }
}

class GHSBColorValueInputBuilder
    implements Builder<GHSBColorValueInput, GHSBColorValueInputBuilder> {
  _$GHSBColorValueInput? _$v;

  int? _h;
  int? get h => _$this._h;
  set h(int? h) => _$this._h = h;

  int? _s;
  int? get s => _$this._s;
  set s(int? s) => _$this._s = s;

  int? _b;
  int? get b => _$this._b;
  set b(int? b) => _$this._b = b;

  GHSBColorValueInputBuilder();

  GHSBColorValueInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _h = $v.h;
      _s = $v.s;
      _b = $v.b;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GHSBColorValueInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GHSBColorValueInput;
  }

  @override
  void update(void Function(GHSBColorValueInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GHSBColorValueInput build() {
    final _$result = _$v ??
        new _$GHSBColorValueInput._(
            h: BuiltValueNullFieldError.checkNotNull(
                h, 'GHSBColorValueInput', 'h'),
            s: BuiltValueNullFieldError.checkNotNull(
                s, 'GHSBColorValueInput', 's'),
            b: BuiltValueNullFieldError.checkNotNull(
                b, 'GHSBColorValueInput', 'b'));
    replace(_$result);
    return _$result;
  }
}

class _$GPinCodeCredentialInput extends GPinCodeCredentialInput {
  @override
  final String pinCode;
  @override
  final String name;
  @override
  final BuiltList<GRRuleSchedule> schedules;

  factory _$GPinCodeCredentialInput(
          [void Function(GPinCodeCredentialInputBuilder)? updates]) =>
      (new GPinCodeCredentialInputBuilder()..update(updates)).build();

  _$GPinCodeCredentialInput._(
      {required this.pinCode, required this.name, required this.schedules})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        pinCode, 'GPinCodeCredentialInput', 'pinCode');
    BuiltValueNullFieldError.checkNotNull(
        name, 'GPinCodeCredentialInput', 'name');
    BuiltValueNullFieldError.checkNotNull(
        schedules, 'GPinCodeCredentialInput', 'schedules');
  }

  @override
  GPinCodeCredentialInput rebuild(
          void Function(GPinCodeCredentialInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GPinCodeCredentialInputBuilder toBuilder() =>
      new GPinCodeCredentialInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GPinCodeCredentialInput &&
        pinCode == other.pinCode &&
        name == other.name &&
        schedules == other.schedules;
  }

  @override
  int get hashCode {
    return $jf(
        $jc($jc($jc(0, pinCode.hashCode), name.hashCode), schedules.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GPinCodeCredentialInput')
          ..add('pinCode', pinCode)
          ..add('name', name)
          ..add('schedules', schedules))
        .toString();
  }
}

class GPinCodeCredentialInputBuilder
    implements
        Builder<GPinCodeCredentialInput, GPinCodeCredentialInputBuilder> {
  _$GPinCodeCredentialInput? _$v;

  String? _pinCode;
  String? get pinCode => _$this._pinCode;
  set pinCode(String? pinCode) => _$this._pinCode = pinCode;

  String? _name;
  String? get name => _$this._name;
  set name(String? name) => _$this._name = name;

  ListBuilder<GRRuleSchedule>? _schedules;
  ListBuilder<GRRuleSchedule> get schedules =>
      _$this._schedules ??= new ListBuilder<GRRuleSchedule>();
  set schedules(ListBuilder<GRRuleSchedule>? schedules) =>
      _$this._schedules = schedules;

  GPinCodeCredentialInputBuilder();

  GPinCodeCredentialInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _pinCode = $v.pinCode;
      _name = $v.name;
      _schedules = $v.schedules.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GPinCodeCredentialInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GPinCodeCredentialInput;
  }

  @override
  void update(void Function(GPinCodeCredentialInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GPinCodeCredentialInput build() {
    _$GPinCodeCredentialInput _$result;
    try {
      _$result = _$v ??
          new _$GPinCodeCredentialInput._(
              pinCode: BuiltValueNullFieldError.checkNotNull(
                  pinCode, 'GPinCodeCredentialInput', 'pinCode'),
              name: BuiltValueNullFieldError.checkNotNull(
                  name, 'GPinCodeCredentialInput', 'name'),
              schedules: schedules.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'schedules';
        schedules.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GPinCodeCredentialInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GRRuleSchedule extends GRRuleSchedule {
  @override
  final String value;

  factory _$GRRuleSchedule([void Function(GRRuleScheduleBuilder)? updates]) =>
      (new GRRuleScheduleBuilder()..update(updates)).build();

  _$GRRuleSchedule._({required this.value}) : super._() {
    BuiltValueNullFieldError.checkNotNull(value, 'GRRuleSchedule', 'value');
  }

  @override
  GRRuleSchedule rebuild(void Function(GRRuleScheduleBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GRRuleScheduleBuilder toBuilder() =>
      new GRRuleScheduleBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GRRuleSchedule && value == other.value;
  }

  @override
  int get hashCode {
    return $jf($jc(0, value.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GRRuleSchedule')..add('value', value))
        .toString();
  }
}

class GRRuleScheduleBuilder
    implements Builder<GRRuleSchedule, GRRuleScheduleBuilder> {
  _$GRRuleSchedule? _$v;

  String? _value;
  String? get value => _$this._value;
  set value(String? value) => _$this._value = value;

  GRRuleScheduleBuilder();

  GRRuleScheduleBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _value = $v.value;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GRRuleSchedule other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GRRuleSchedule;
  }

  @override
  void update(void Function(GRRuleScheduleBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GRRuleSchedule build() {
    final _$result = _$v ??
        new _$GRRuleSchedule._(
            value: BuiltValueNullFieldError.checkNotNull(
                value, 'GRRuleSchedule', 'value'));
    replace(_$result);
    return _$result;
  }
}

class _$GPinCodeCredentialItemInput extends GPinCodeCredentialItemInput {
  @override
  final String pinCode;
  @override
  final String name;
  @override
  final bool alwaysActive;
  @override
  final BuiltList<GRecurringScheduleInput> recurringSchedules;
  @override
  final BuiltList<GTemporaryScheduleInput> temporarySchedules;

  factory _$GPinCodeCredentialItemInput(
          [void Function(GPinCodeCredentialItemInputBuilder)? updates]) =>
      (new GPinCodeCredentialItemInputBuilder()..update(updates)).build();

  _$GPinCodeCredentialItemInput._(
      {required this.pinCode,
      required this.name,
      required this.alwaysActive,
      required this.recurringSchedules,
      required this.temporarySchedules})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        pinCode, 'GPinCodeCredentialItemInput', 'pinCode');
    BuiltValueNullFieldError.checkNotNull(
        name, 'GPinCodeCredentialItemInput', 'name');
    BuiltValueNullFieldError.checkNotNull(
        alwaysActive, 'GPinCodeCredentialItemInput', 'alwaysActive');
    BuiltValueNullFieldError.checkNotNull(recurringSchedules,
        'GPinCodeCredentialItemInput', 'recurringSchedules');
    BuiltValueNullFieldError.checkNotNull(temporarySchedules,
        'GPinCodeCredentialItemInput', 'temporarySchedules');
  }

  @override
  GPinCodeCredentialItemInput rebuild(
          void Function(GPinCodeCredentialItemInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GPinCodeCredentialItemInputBuilder toBuilder() =>
      new GPinCodeCredentialItemInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GPinCodeCredentialItemInput &&
        pinCode == other.pinCode &&
        name == other.name &&
        alwaysActive == other.alwaysActive &&
        recurringSchedules == other.recurringSchedules &&
        temporarySchedules == other.temporarySchedules;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc($jc($jc(0, pinCode.hashCode), name.hashCode),
                alwaysActive.hashCode),
            recurringSchedules.hashCode),
        temporarySchedules.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GPinCodeCredentialItemInput')
          ..add('pinCode', pinCode)
          ..add('name', name)
          ..add('alwaysActive', alwaysActive)
          ..add('recurringSchedules', recurringSchedules)
          ..add('temporarySchedules', temporarySchedules))
        .toString();
  }
}

class GPinCodeCredentialItemInputBuilder
    implements
        Builder<GPinCodeCredentialItemInput,
            GPinCodeCredentialItemInputBuilder> {
  _$GPinCodeCredentialItemInput? _$v;

  String? _pinCode;
  String? get pinCode => _$this._pinCode;
  set pinCode(String? pinCode) => _$this._pinCode = pinCode;

  String? _name;
  String? get name => _$this._name;
  set name(String? name) => _$this._name = name;

  bool? _alwaysActive;
  bool? get alwaysActive => _$this._alwaysActive;
  set alwaysActive(bool? alwaysActive) => _$this._alwaysActive = alwaysActive;

  ListBuilder<GRecurringScheduleInput>? _recurringSchedules;
  ListBuilder<GRecurringScheduleInput> get recurringSchedules =>
      _$this._recurringSchedules ??= new ListBuilder<GRecurringScheduleInput>();
  set recurringSchedules(
          ListBuilder<GRecurringScheduleInput>? recurringSchedules) =>
      _$this._recurringSchedules = recurringSchedules;

  ListBuilder<GTemporaryScheduleInput>? _temporarySchedules;
  ListBuilder<GTemporaryScheduleInput> get temporarySchedules =>
      _$this._temporarySchedules ??= new ListBuilder<GTemporaryScheduleInput>();
  set temporarySchedules(
          ListBuilder<GTemporaryScheduleInput>? temporarySchedules) =>
      _$this._temporarySchedules = temporarySchedules;

  GPinCodeCredentialItemInputBuilder();

  GPinCodeCredentialItemInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _pinCode = $v.pinCode;
      _name = $v.name;
      _alwaysActive = $v.alwaysActive;
      _recurringSchedules = $v.recurringSchedules.toBuilder();
      _temporarySchedules = $v.temporarySchedules.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GPinCodeCredentialItemInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GPinCodeCredentialItemInput;
  }

  @override
  void update(void Function(GPinCodeCredentialItemInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GPinCodeCredentialItemInput build() {
    _$GPinCodeCredentialItemInput _$result;
    try {
      _$result = _$v ??
          new _$GPinCodeCredentialItemInput._(
              pinCode: BuiltValueNullFieldError.checkNotNull(
                  pinCode, 'GPinCodeCredentialItemInput', 'pinCode'),
              name: BuiltValueNullFieldError.checkNotNull(
                  name, 'GPinCodeCredentialItemInput', 'name'),
              alwaysActive: BuiltValueNullFieldError.checkNotNull(
                  alwaysActive, 'GPinCodeCredentialItemInput', 'alwaysActive'),
              recurringSchedules: recurringSchedules.build(),
              temporarySchedules: temporarySchedules.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'recurringSchedules';
        recurringSchedules.build();
        _$failedField = 'temporarySchedules';
        temporarySchedules.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GPinCodeCredentialItemInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GRecurringScheduleInput extends GRecurringScheduleInput {
  @override
  final int duration;
  @override
  final GRRuleSchedule rrule;

  factory _$GRecurringScheduleInput(
          [void Function(GRecurringScheduleInputBuilder)? updates]) =>
      (new GRecurringScheduleInputBuilder()..update(updates)).build();

  _$GRecurringScheduleInput._({required this.duration, required this.rrule})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        duration, 'GRecurringScheduleInput', 'duration');
    BuiltValueNullFieldError.checkNotNull(
        rrule, 'GRecurringScheduleInput', 'rrule');
  }

  @override
  GRecurringScheduleInput rebuild(
          void Function(GRecurringScheduleInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GRecurringScheduleInputBuilder toBuilder() =>
      new GRecurringScheduleInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GRecurringScheduleInput &&
        duration == other.duration &&
        rrule == other.rrule;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, duration.hashCode), rrule.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GRecurringScheduleInput')
          ..add('duration', duration)
          ..add('rrule', rrule))
        .toString();
  }
}

class GRecurringScheduleInputBuilder
    implements
        Builder<GRecurringScheduleInput, GRecurringScheduleInputBuilder> {
  _$GRecurringScheduleInput? _$v;

  int? _duration;
  int? get duration => _$this._duration;
  set duration(int? duration) => _$this._duration = duration;

  GRRuleScheduleBuilder? _rrule;
  GRRuleScheduleBuilder get rrule =>
      _$this._rrule ??= new GRRuleScheduleBuilder();
  set rrule(GRRuleScheduleBuilder? rrule) => _$this._rrule = rrule;

  GRecurringScheduleInputBuilder();

  GRecurringScheduleInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _duration = $v.duration;
      _rrule = $v.rrule.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GRecurringScheduleInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GRecurringScheduleInput;
  }

  @override
  void update(void Function(GRecurringScheduleInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GRecurringScheduleInput build() {
    _$GRecurringScheduleInput _$result;
    try {
      _$result = _$v ??
          new _$GRecurringScheduleInput._(
              duration: BuiltValueNullFieldError.checkNotNull(
                  duration, 'GRecurringScheduleInput', 'duration'),
              rrule: rrule.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'rrule';
        rrule.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GRecurringScheduleInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GTemporaryScheduleInput extends GTemporaryScheduleInput {
  @override
  final GDateTime startDatetime;
  @override
  final GDateTime endDatetime;

  factory _$GTemporaryScheduleInput(
          [void Function(GTemporaryScheduleInputBuilder)? updates]) =>
      (new GTemporaryScheduleInputBuilder()..update(updates)).build();

  _$GTemporaryScheduleInput._(
      {required this.startDatetime, required this.endDatetime})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        startDatetime, 'GTemporaryScheduleInput', 'startDatetime');
    BuiltValueNullFieldError.checkNotNull(
        endDatetime, 'GTemporaryScheduleInput', 'endDatetime');
  }

  @override
  GTemporaryScheduleInput rebuild(
          void Function(GTemporaryScheduleInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GTemporaryScheduleInputBuilder toBuilder() =>
      new GTemporaryScheduleInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GTemporaryScheduleInput &&
        startDatetime == other.startDatetime &&
        endDatetime == other.endDatetime;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, startDatetime.hashCode), endDatetime.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GTemporaryScheduleInput')
          ..add('startDatetime', startDatetime)
          ..add('endDatetime', endDatetime))
        .toString();
  }
}

class GTemporaryScheduleInputBuilder
    implements
        Builder<GTemporaryScheduleInput, GTemporaryScheduleInputBuilder> {
  _$GTemporaryScheduleInput? _$v;

  GDateTimeBuilder? _startDatetime;
  GDateTimeBuilder get startDatetime =>
      _$this._startDatetime ??= new GDateTimeBuilder();
  set startDatetime(GDateTimeBuilder? startDatetime) =>
      _$this._startDatetime = startDatetime;

  GDateTimeBuilder? _endDatetime;
  GDateTimeBuilder get endDatetime =>
      _$this._endDatetime ??= new GDateTimeBuilder();
  set endDatetime(GDateTimeBuilder? endDatetime) =>
      _$this._endDatetime = endDatetime;

  GTemporaryScheduleInputBuilder();

  GTemporaryScheduleInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _startDatetime = $v.startDatetime.toBuilder();
      _endDatetime = $v.endDatetime.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GTemporaryScheduleInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GTemporaryScheduleInput;
  }

  @override
  void update(void Function(GTemporaryScheduleInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GTemporaryScheduleInput build() {
    _$GTemporaryScheduleInput _$result;
    try {
      _$result = _$v ??
          new _$GTemporaryScheduleInput._(
              startDatetime: startDatetime.build(),
              endDatetime: endDatetime.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'startDatetime';
        startDatetime.build();
        _$failedField = 'endDatetime';
        endDatetime.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GTemporaryScheduleInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GDateTime extends GDateTime {
  @override
  final String value;

  factory _$GDateTime([void Function(GDateTimeBuilder)? updates]) =>
      (new GDateTimeBuilder()..update(updates)).build();

  _$GDateTime._({required this.value}) : super._() {
    BuiltValueNullFieldError.checkNotNull(value, 'GDateTime', 'value');
  }

  @override
  GDateTime rebuild(void Function(GDateTimeBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GDateTimeBuilder toBuilder() => new GDateTimeBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GDateTime && value == other.value;
  }

  @override
  int get hashCode {
    return $jf($jc(0, value.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GDateTime')..add('value', value))
        .toString();
  }
}

class GDateTimeBuilder implements Builder<GDateTime, GDateTimeBuilder> {
  _$GDateTime? _$v;

  String? _value;
  String? get value => _$this._value;
  set value(String? value) => _$this._value = value;

  GDateTimeBuilder();

  GDateTimeBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _value = $v.value;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GDateTime other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GDateTime;
  }

  @override
  void update(void Function(GDateTimeBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GDateTime build() {
    final _$result = _$v ??
        new _$GDateTime._(
            value: BuiltValueNullFieldError.checkNotNull(
                value, 'GDateTime', 'value'));
    replace(_$result);
    return _$result;
  }
}

class _$GThermostatRangeInput extends GThermostatRangeInput {
  @override
  final double setPointLow;
  @override
  final double setPointHigh;

  factory _$GThermostatRangeInput(
          [void Function(GThermostatRangeInputBuilder)? updates]) =>
      (new GThermostatRangeInputBuilder()..update(updates)).build();

  _$GThermostatRangeInput._(
      {required this.setPointLow, required this.setPointHigh})
      : super._() {
    BuiltValueNullFieldError.checkNotNull(
        setPointLow, 'GThermostatRangeInput', 'setPointLow');
    BuiltValueNullFieldError.checkNotNull(
        setPointHigh, 'GThermostatRangeInput', 'setPointHigh');
  }

  @override
  GThermostatRangeInput rebuild(
          void Function(GThermostatRangeInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GThermostatRangeInputBuilder toBuilder() =>
      new GThermostatRangeInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GThermostatRangeInput &&
        setPointLow == other.setPointLow &&
        setPointHigh == other.setPointHigh;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, setPointLow.hashCode), setPointHigh.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GThermostatRangeInput')
          ..add('setPointLow', setPointLow)
          ..add('setPointHigh', setPointHigh))
        .toString();
  }
}

class GThermostatRangeInputBuilder
    implements Builder<GThermostatRangeInput, GThermostatRangeInputBuilder> {
  _$GThermostatRangeInput? _$v;

  double? _setPointLow;
  double? get setPointLow => _$this._setPointLow;
  set setPointLow(double? setPointLow) => _$this._setPointLow = setPointLow;

  double? _setPointHigh;
  double? get setPointHigh => _$this._setPointHigh;
  set setPointHigh(double? setPointHigh) => _$this._setPointHigh = setPointHigh;

  GThermostatRangeInputBuilder();

  GThermostatRangeInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _setPointLow = $v.setPointLow;
      _setPointHigh = $v.setPointHigh;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GThermostatRangeInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GThermostatRangeInput;
  }

  @override
  void update(void Function(GThermostatRangeInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GThermostatRangeInput build() {
    final _$result = _$v ??
        new _$GThermostatRangeInput._(
            setPointLow: BuiltValueNullFieldError.checkNotNull(
                setPointLow, 'GThermostatRangeInput', 'setPointLow'),
            setPointHigh: BuiltValueNullFieldError.checkNotNull(
                setPointHigh, 'GThermostatRangeInput', 'setPointHigh'));
    replace(_$result);
    return _$result;
  }
}

class _$GJSONObject extends GJSONObject {
  @override
  final String value;

  factory _$GJSONObject([void Function(GJSONObjectBuilder)? updates]) =>
      (new GJSONObjectBuilder()..update(updates)).build();

  _$GJSONObject._({required this.value}) : super._() {
    BuiltValueNullFieldError.checkNotNull(value, 'GJSONObject', 'value');
  }

  @override
  GJSONObject rebuild(void Function(GJSONObjectBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GJSONObjectBuilder toBuilder() => new GJSONObjectBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GJSONObject && value == other.value;
  }

  @override
  int get hashCode {
    return $jf($jc(0, value.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GJSONObject')..add('value', value))
        .toString();
  }
}

class GJSONObjectBuilder implements Builder<GJSONObject, GJSONObjectBuilder> {
  _$GJSONObject? _$v;

  String? _value;
  String? get value => _$this._value;
  set value(String? value) => _$this._value = value;

  GJSONObjectBuilder();

  GJSONObjectBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _value = $v.value;
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GJSONObject other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GJSONObject;
  }

  @override
  void update(void Function(GJSONObjectBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GJSONObject build() {
    final _$result = _$v ??
        new _$GJSONObject._(
            value: BuiltValueNullFieldError.checkNotNull(
                value, 'GJSONObject', 'value'));
    replace(_$result);
    return _$result;
  }
}

class _$GMockReportedListStateValue extends GMockReportedListStateValue {
  @override
  final BuiltList<GJSONObject>? upsert;
  @override
  final BuiltList<String>? delete;

  factory _$GMockReportedListStateValue(
          [void Function(GMockReportedListStateValueBuilder)? updates]) =>
      (new GMockReportedListStateValueBuilder()..update(updates)).build();

  _$GMockReportedListStateValue._({this.upsert, this.delete}) : super._();

  @override
  GMockReportedListStateValue rebuild(
          void Function(GMockReportedListStateValueBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GMockReportedListStateValueBuilder toBuilder() =>
      new GMockReportedListStateValueBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GMockReportedListStateValue &&
        upsert == other.upsert &&
        delete == other.delete;
  }

  @override
  int get hashCode {
    return $jf($jc($jc(0, upsert.hashCode), delete.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GMockReportedListStateValue')
          ..add('upsert', upsert)
          ..add('delete', delete))
        .toString();
  }
}

class GMockReportedListStateValueBuilder
    implements
        Builder<GMockReportedListStateValue,
            GMockReportedListStateValueBuilder> {
  _$GMockReportedListStateValue? _$v;

  ListBuilder<GJSONObject>? _upsert;
  ListBuilder<GJSONObject> get upsert =>
      _$this._upsert ??= new ListBuilder<GJSONObject>();
  set upsert(ListBuilder<GJSONObject>? upsert) => _$this._upsert = upsert;

  ListBuilder<String>? _delete;
  ListBuilder<String> get delete =>
      _$this._delete ??= new ListBuilder<String>();
  set delete(ListBuilder<String>? delete) => _$this._delete = delete;

  GMockReportedListStateValueBuilder();

  GMockReportedListStateValueBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _upsert = $v.upsert?.toBuilder();
      _delete = $v.delete?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GMockReportedListStateValue other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GMockReportedListStateValue;
  }

  @override
  void update(void Function(GMockReportedListStateValueBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GMockReportedListStateValue build() {
    _$GMockReportedListStateValue _$result;
    try {
      _$result = _$v ??
          new _$GMockReportedListStateValue._(
              upsert: _upsert?.build(), delete: _delete?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'upsert';
        _upsert?.build();
        _$failedField = 'delete';
        _delete?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GMockReportedListStateValue', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GDeviceFilterInput extends GDeviceFilterInput {
  @override
  final BuiltList<GTraitName> traits;

  factory _$GDeviceFilterInput(
          [void Function(GDeviceFilterInputBuilder)? updates]) =>
      (new GDeviceFilterInputBuilder()..update(updates)).build();

  _$GDeviceFilterInput._({required this.traits}) : super._() {
    BuiltValueNullFieldError.checkNotNull(
        traits, 'GDeviceFilterInput', 'traits');
  }

  @override
  GDeviceFilterInput rebuild(
          void Function(GDeviceFilterInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GDeviceFilterInputBuilder toBuilder() =>
      new GDeviceFilterInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GDeviceFilterInput && traits == other.traits;
  }

  @override
  int get hashCode {
    return $jf($jc(0, traits.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GDeviceFilterInput')
          ..add('traits', traits))
        .toString();
  }
}

class GDeviceFilterInputBuilder
    implements Builder<GDeviceFilterInput, GDeviceFilterInputBuilder> {
  _$GDeviceFilterInput? _$v;

  ListBuilder<GTraitName>? _traits;
  ListBuilder<GTraitName> get traits =>
      _$this._traits ??= new ListBuilder<GTraitName>();
  set traits(ListBuilder<GTraitName>? traits) => _$this._traits = traits;

  GDeviceFilterInputBuilder();

  GDeviceFilterInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _traits = $v.traits.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GDeviceFilterInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GDeviceFilterInput;
  }

  @override
  void update(void Function(GDeviceFilterInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GDeviceFilterInput build() {
    _$GDeviceFilterInput _$result;
    try {
      _$result = _$v ?? new _$GDeviceFilterInput._(traits: traits.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'traits';
        traits.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GDeviceFilterInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GDeviceEventFilterInput extends GDeviceEventFilterInput {
  @override
  final GDeviceEventTypeName? eventType;
  @override
  final GDateTime? before;
  @override
  final GDateTime? after;
  @override
  final String? traitInstance;
  @override
  final BuiltList<GTraitName>? traits;

  factory _$GDeviceEventFilterInput(
          [void Function(GDeviceEventFilterInputBuilder)? updates]) =>
      (new GDeviceEventFilterInputBuilder()..update(updates)).build();

  _$GDeviceEventFilterInput._(
      {this.eventType,
      this.before,
      this.after,
      this.traitInstance,
      this.traits})
      : super._();

  @override
  GDeviceEventFilterInput rebuild(
          void Function(GDeviceEventFilterInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GDeviceEventFilterInputBuilder toBuilder() =>
      new GDeviceEventFilterInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GDeviceEventFilterInput &&
        eventType == other.eventType &&
        before == other.before &&
        after == other.after &&
        traitInstance == other.traitInstance &&
        traits == other.traits;
  }

  @override
  int get hashCode {
    return $jf($jc(
        $jc(
            $jc($jc($jc(0, eventType.hashCode), before.hashCode),
                after.hashCode),
            traitInstance.hashCode),
        traits.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GDeviceEventFilterInput')
          ..add('eventType', eventType)
          ..add('before', before)
          ..add('after', after)
          ..add('traitInstance', traitInstance)
          ..add('traits', traits))
        .toString();
  }
}

class GDeviceEventFilterInputBuilder
    implements
        Builder<GDeviceEventFilterInput, GDeviceEventFilterInputBuilder> {
  _$GDeviceEventFilterInput? _$v;

  GDeviceEventTypeName? _eventType;
  GDeviceEventTypeName? get eventType => _$this._eventType;
  set eventType(GDeviceEventTypeName? eventType) =>
      _$this._eventType = eventType;

  GDateTimeBuilder? _before;
  GDateTimeBuilder get before => _$this._before ??= new GDateTimeBuilder();
  set before(GDateTimeBuilder? before) => _$this._before = before;

  GDateTimeBuilder? _after;
  GDateTimeBuilder get after => _$this._after ??= new GDateTimeBuilder();
  set after(GDateTimeBuilder? after) => _$this._after = after;

  String? _traitInstance;
  String? get traitInstance => _$this._traitInstance;
  set traitInstance(String? traitInstance) =>
      _$this._traitInstance = traitInstance;

  ListBuilder<GTraitName>? _traits;
  ListBuilder<GTraitName> get traits =>
      _$this._traits ??= new ListBuilder<GTraitName>();
  set traits(ListBuilder<GTraitName>? traits) => _$this._traits = traits;

  GDeviceEventFilterInputBuilder();

  GDeviceEventFilterInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _eventType = $v.eventType;
      _before = $v.before?.toBuilder();
      _after = $v.after?.toBuilder();
      _traitInstance = $v.traitInstance;
      _traits = $v.traits?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GDeviceEventFilterInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GDeviceEventFilterInput;
  }

  @override
  void update(void Function(GDeviceEventFilterInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GDeviceEventFilterInput build() {
    _$GDeviceEventFilterInput _$result;
    try {
      _$result = _$v ??
          new _$GDeviceEventFilterInput._(
              eventType: eventType,
              before: _before?.build(),
              after: _after?.build(),
              traitInstance: traitInstance,
              traits: _traits?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'before';
        _before?.build();
        _$failedField = 'after';
        _after?.build();

        _$failedField = 'traits';
        _traits?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GDeviceEventFilterInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

class _$GTraitFilteredEventFilterInput extends GTraitFilteredEventFilterInput {
  @override
  final GDeviceEventTypeName? eventType;
  @override
  final GDateTime? before;
  @override
  final GDateTime? after;

  factory _$GTraitFilteredEventFilterInput(
          [void Function(GTraitFilteredEventFilterInputBuilder)? updates]) =>
      (new GTraitFilteredEventFilterInputBuilder()..update(updates)).build();

  _$GTraitFilteredEventFilterInput._({this.eventType, this.before, this.after})
      : super._();

  @override
  GTraitFilteredEventFilterInput rebuild(
          void Function(GTraitFilteredEventFilterInputBuilder) updates) =>
      (toBuilder()..update(updates)).build();

  @override
  GTraitFilteredEventFilterInputBuilder toBuilder() =>
      new GTraitFilteredEventFilterInputBuilder()..replace(this);

  @override
  bool operator ==(Object other) {
    if (identical(other, this)) return true;
    return other is GTraitFilteredEventFilterInput &&
        eventType == other.eventType &&
        before == other.before &&
        after == other.after;
  }

  @override
  int get hashCode {
    return $jf(
        $jc($jc($jc(0, eventType.hashCode), before.hashCode), after.hashCode));
  }

  @override
  String toString() {
    return (newBuiltValueToStringHelper('GTraitFilteredEventFilterInput')
          ..add('eventType', eventType)
          ..add('before', before)
          ..add('after', after))
        .toString();
  }
}

class GTraitFilteredEventFilterInputBuilder
    implements
        Builder<GTraitFilteredEventFilterInput,
            GTraitFilteredEventFilterInputBuilder> {
  _$GTraitFilteredEventFilterInput? _$v;

  GDeviceEventTypeName? _eventType;
  GDeviceEventTypeName? get eventType => _$this._eventType;
  set eventType(GDeviceEventTypeName? eventType) =>
      _$this._eventType = eventType;

  GDateTimeBuilder? _before;
  GDateTimeBuilder get before => _$this._before ??= new GDateTimeBuilder();
  set before(GDateTimeBuilder? before) => _$this._before = before;

  GDateTimeBuilder? _after;
  GDateTimeBuilder get after => _$this._after ??= new GDateTimeBuilder();
  set after(GDateTimeBuilder? after) => _$this._after = after;

  GTraitFilteredEventFilterInputBuilder();

  GTraitFilteredEventFilterInputBuilder get _$this {
    final $v = _$v;
    if ($v != null) {
      _eventType = $v.eventType;
      _before = $v.before?.toBuilder();
      _after = $v.after?.toBuilder();
      _$v = null;
    }
    return this;
  }

  @override
  void replace(GTraitFilteredEventFilterInput other) {
    ArgumentError.checkNotNull(other, 'other');
    _$v = other as _$GTraitFilteredEventFilterInput;
  }

  @override
  void update(void Function(GTraitFilteredEventFilterInputBuilder)? updates) {
    if (updates != null) updates(this);
  }

  @override
  _$GTraitFilteredEventFilterInput build() {
    _$GTraitFilteredEventFilterInput _$result;
    try {
      _$result = _$v ??
          new _$GTraitFilteredEventFilterInput._(
              eventType: eventType,
              before: _before?.build(),
              after: _after?.build());
    } catch (_) {
      late String _$failedField;
      try {
        _$failedField = 'before';
        _before?.build();
        _$failedField = 'after';
        _after?.build();
      } catch (e) {
        throw new BuiltValueNestedFieldError(
            'GTraitFilteredEventFilterInput', _$failedField, e.toString());
      }
      rethrow;
    }
    replace(_$result);
    return _$result;
  }
}

// ignore_for_file: always_put_control_body_on_new_line,always_specify_types,annotate_overrides,avoid_annotating_with_dynamic,avoid_as,avoid_catches_without_on_clauses,avoid_returning_this,deprecated_member_use_from_same_package,lines_longer_than_80_chars,omit_local_variable_types,prefer_expression_function_bodies,sort_constructors_first,test_types_in_equals,unnecessary_const,unnecessary_new
